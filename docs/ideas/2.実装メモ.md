# **AI Agent System \- 実装メモ**

このドキュメントは、AIエージェントシステムを実装するためのアイディア、メモ、計画を蓄積していくためのものです。

## **1\. 基本方針 & 技術スタック**

* **言語:** TypeScript, Python (DB層)  
* **プロセス間通信:** JSON-RPC over stdio (標準入出力)  
* **データベース:** LanceDB (Pythonプロセス経由で利用)  
* **AIドライバ:** 独自開発の生成AIドライバ  
* **プロンプトフレームワーク:** 独自開発の「Modularプロンプト」フレームワーク  
* **実行環境:** Node.js

## **2\. 実装のコア要素**

### **2.1. Core Agent (イベントキュー & 思考エンジン)**

* **コンセプト:** イベントキューをベースにした思考ループ。  
* **処理フロー:**  
  1. イベントキューからイベントを1つ取り出す。  
  2. イベントの種類に応じて、対応する「思考ワークフロー」を実行する。  
  3. ワークフローは、DBからのデータ取得、生成AIへの問い合わせ、DBへの書き込みなどを行う。  
  4. ワークフローの実行結果として、新たなイベントをキューに追加することもある。  
  5. キューが空になるか、一定の長さになるまでループを継続する。

### **2.2. 思考ワークフロー (Cognitive Workflows)**

* **定義:** 特定の目的を達成するための一連の処理手順。ハードコーディングされたロジックと、生成AIへのプロンプトで構成される。  
* **役割:**  
  * AI自身の思考プロセスそのもの。単なる外部ツール呼び出しではない。  
  * 各ワークフローは、自身の役割、使い方、必要なデータなどのメタ情報を持つ。  
* **スケジューリング:** Core Agentは、これらのワークフローのメタ情報を参照し、次にどのワークフローを実行すべきかを判断・スケジューリングする。  
* **文脈共有:** **全てのワークフローは、実行時に単一の「状態文書 (State)」を読み込み、現在の全体文脈を把握した上で動作する。**

### **2.3. 主要な思考ワークフローの洗い出し**

* **A: 個別要素の処理 (Individual Scope)**  
  * **A-0: PROCESS\_USER\_REQUEST:** ユーザーからの直接のrequestを解釈し、意図（情報登録、ルール設定、質問など）に応じて後続のワークフローを起動する最上位のワークフロー。  
  * **A-1: INGEST\_INPUT:** Reporterから投入されたInputをIssueに変換し、関連するFlowを探索して紐付ける。  
  * **A-2: ANALYZE\_ISSUE\_IMPACT:** Issueが更新された際に、関連するFlowや他のIssueへの影響を分析する。  
  * **A-3: EXTRACT\_KNOWLEDGE:** 完了したIssueから、再利用可能なKnowledgeを抽出・生成する。  
  * **A-4: DEFINE\_SYSTEM\_RULE:** ユーザーの指示に基づき、type: 'system\_rule'のKnowledgeを生成する。  
* **B: 横断的な分析と整理 (Global Scope)**  
  * **B-1: CLUSTER\_ISSUES:** ラベルやdescriptionが類似しているIssueをクラスタリングし、新たなFlowの生成を提案する。  
  * **B-2: UPDATE\_FLOW\_RELATIONS:** Flowのdescription（自然言語）を解釈し、Issue間の依存関係（relations）を更新する。  
  * **B-3: UPDATE\_FLOW\_PRIORITIES:** 全Flowの状態と、type: 'system\_rule'のKnowledge（例: 「金曜は企画を優先」）を考慮し、各FlowのpriorityScoreを再計算する。  
  * **B-4: SALVAGE\_FROM\_POND:** Pond内の情報をクラスタリングし、価値のある情報や関連するIssue/Flowを発見する。  
  * **B-5: REFLECT\_AND\_ORGANIZE\_STATE:** 現在の「状態文書」全体を読み込み、内容を整理・要約して自己矛盾を解消したり、重要な情報をIssueやKnowledgeとして構造化することを提案したりする、自己言及的なワークフロー。  
* **C: ユーザーへの提案 (Suggestion Scope)**  
  * **C-1: SUGGEST\_NEXT\_FLOW:** Flowの優先度に基づき、ユーザーが次に着手すべきFlowを提案する。  
  * **C-2: SUGGEST\_NEXT\_ACTION\_FOR\_ISSUE:** 特定のIssueについて、次に取るべき具体的なアクションをupdatesに追記する形で提案する。  
* **D: システムの自己調整 (System Self-Tuning)**  
  * **D-1: TUNE\_SYSTEM\_PARAMETERS:** D-2で収集した現在の統計情報と、Knowledgeとして定義された「目標指標」を比較し、システムの振る舞いを決定する各種パラメータ（例: Pondのサルベージ頻度、Flowの優先度計算アルゴリズムの重み付け）を自律的に調整する。  
  * **D-2: COLLECT\_SYSTEM\_STATS:** システム全体の活動に関する統計情報を定期的に収集し、DBに保存する。

### **2.4. データモデル (TypeScript Interfaces)**

``// パッケージ間で共有される型定義 (`shared-types`に配置)``

`interface Input {`  
  `id: string;`  
  `source: string; // "slack", "gmail", "manual"`  
  `content: string;`  
  `timestamp: Date;`  
`}`

`interface Issue {`  
  `id: string;`  
  `title: string;`  
  `description: string; // 自然言語での詳細。ベクトル化の対象`  
  `status: 'open' | 'closed';`  
  `labels: string[];`  
  `updates: IssueUpdate[]; // 履歴`  
  `relations: IssueRelation[]; // 他のIssueとの関係性`  
  `sourceInputIds: string[];`  
`}`

`interface IssueUpdate {`  
  `timestamp: Date;`  
  `content: string;`  
  `author: 'user' | 'ai'; // ユーザーのメモか、AIの提案か`  
`}`

`interface IssueRelation {`  
  `type: 'blocks' | 'relates_to' | 'duplicates' | 'parent_of';`  
  `targetIssueId: string;`  
`}`

`interface Flow {`  
  `id: string;`  
  `title:string;`  
  `description: string; // このフローの目的や依存関係。自然言語で記述`  
  `status: 'focused' | 'active' | 'monitoring' | 'blocked' | 'pending_user_decision' | 'pending_review' | 'backlog' | 'paused' | 'someday' | 'completed' | 'cancelled' | 'archived';`  
  `priorityScore: number; // 0.0 ~ 1.0 AIが動的に評価`  
  `issueIds: string[];`  
`}`

`// アシスタントがユーザーをサポートするために持つ知識`  
`interface Knowledge {`  
  `id: string;`  
  `// この知識が「何に使う」ものかに基づいて分類する`  
  `type:`  
    `| 'system_rule'       // AIの振る舞いを定義するルール (例: ラベル運用、週次スケジュール、目標指標KPI、調整パラメータ)`  
    `| 'process_manual'    // 定型的な業務フローや手順書`  
    `| 'entity_profile'    // 特定の人物、組織、プロジェクトに関する情報`  
    `| 'curated_summary'   // 特定のトピックについて横断的に集められた要約情報`  
    `| 'factoid';          // 再利用可能な単一の事実や情報`  
  `content: string;        // 知識の本体 (自然言語)`  
  `reputation: {`  
    `upvotes: number;`  
    `downvotes: number;`  
  `};`  
  `sources: KnowledgeSource[]; // この知識を構成する情報源 (複数)`  
`}`

`type KnowledgeSource =`  
  `| { type: 'issue', issueId: string }`  
  `| { type: 'pond', pondEntryId: string }`  
  `| { type: 'user_direct' }`  
  `| { type: 'knowledge', knowledgeId: string }; // 他のKnowledgeを参照`

`// Stateは構造化された型を持たない。システム全体で共有される単一の自然言語ドキュメント(string)として扱われる。`

### **2.5. MCPサーバー (mcp-server パッケージ)**

* **役割:** 外部のAIエージェント（クライアント）との通信を担うサーバープロセス。  
* **プロトコル:** 標準入出力(stdin/stdout)を介してJSONをやり取りする。  
* **機能:**  
  * 外部AIから受け取ったリクエストを解釈し、api-restパッケージのREST APIを呼び出す。  
  * api-restからのレスポンスを、外部AIが理解できる形式に整形して返す。  
* **メソッド:**  
  * **構造化データ用:**  
    * request(prompt: string): ユーザーからの自然言語リクエストをCore Agentに送信する。  
    * get(params: GetParams): 特定のIDのオブジェクトを1件取得する。  
    * list(params: ListParams): 条件に合うオブジェクトを複数件取得する。  
    * search(params: SearchParams): 自然言語クエリで横断的にオブジェクトを検索する。  
  * **短期記憶用:**  
    * getStateDocument(): Promise\<string\>  
    * updateStateDocument(content: string): Promise\<void\>

### **2.6. DB層 (db パッケージ) \- JSON-RPC over stdio**

LanceDBをTypeScriptアプリケーションから透過的に利用するためのブリッジ層。

* **役割:**  
  * TypeScriptの世界とPythonで動作するLanceDBの世界を、軽量なプロセス間通信で繋ぐ。  
  * 他のTypeScriptパッケージに対して、バックエンドの実装（Python/LanceDB）を隠蔽する。  
* **構成:**  
  1. **Python RPCワーカー (lancedb\_worker.py):**  
     * HTTPサーバーは立てず、自身の**標準入力(stdin)を監視**するシンプルなPythonプロセス。  
     * stdinからJSON-RPCリクエストを受け取り、LanceDBを操作する。  
     * 実行結果をJSON-RPCレスポンスとして**標準出力(stdout)に書き出す**。  
  2. **TypeScriptラッパー (index.ts):**  
     * **プロセス管理:** child\_processモジュールを使い、Python RPCワーカーを子プロセスとして起動・監視・終了させる。  
     * **高レベルAPI:** searchIssues(query: string)のようなメソッドを提供する。内部では、JSON-RPCリクエストを生成して子プロセスのstdinに書き込み、stdoutからの応答を待って結果を返す。  
     * **非同期処理:** 各リクエストに一意のIDを付与することで、複数のDB操作を同時に、ノンブロッキングで実行できる。

### **2.7. REST API (api-rest パッケージ)**

* **役割:** coreパッケージの機能を、内部の他のプロセス（mcp-server, reporters, web-ui）に対してHTTP経由で公開する。  
* **エンドポイント例:**  
  * POST /request: ユーザーからの自然言語リクエストを受け付け、Core Agentに処理を依頼する。  
  * GET /issues/:id: 特定のIssueを取得する。  
  * GET /issues: Issueをリスト/検索する。  
  * GET /flows: Flowをリスト/検索する。  
  * GET /state: 単一の状態文書を取得する。  
  * PUT /state: 単一の状態文書を全体更新する。  
  * GET /stats: システムの健全性に関する統計情報を取得する。

### **2.8. Reporters (情報収集モジュール)**

* **役割:** 外部サービス（Gmail, Slackなど）から情報を収集し、Inputとしてapi-restに送信する独立したプロセス群。

### **2.9. Web UI (web-ui パッケージ)**

* **役割:**  
  * データベース内のIssue, Flow, Knowledgeなどを閲覧するための、開発者向け・あるいはユーザー向けのシンプルなWebインターフェース。  
  * api-restパッケージが提供するエンドポイントを叩いてデータを表示する。  
  * **システム統計情報のダッシュボード機能** を持つ。  
* **技術スタック:** **SvelteKit** を採用。迅速なプロトタイピングと優れたパフォーマンスを両立させる。

### **2.10. 短期記憶: 単一の状態文書 (State as a Single Document)**

* **コンセプト:** システム全体で共有される、**唯一無二のワーキングメモリ**。これはKey-Valueストアではなく、構造化もされていない、単一の自然言語ドキュメントである。  
* **役割:**  
  * **共有された意識:** coreやmcp-server、そして全ての生成AIプロセスが、常に同じ文脈（「今、何を考えているか」「今日の予定は何か」など）を共有するための基盤。  
  * **思考の出発点:** ほぼ全ての思考ワークフローは、処理を開始する前にこの状態文書を読み込み、プロンプトの主要なコンテキストとして利用する。  
  * **流動的な情報の置き場:** 処理の結果、内部構造（章立てなど）がAIによって自律的に更新される。  
* **永続性:** 永続的な保存は保証されるが、その内容は常に変化し続ける。重要な情報は、B-5ワークフローによってIssueやKnowledgeとして構造化され、状態文書からは削除されることがある。  
* **実装:** dbパッケージ内のLanceDBに、この単一ドキュメントを保存するための専用のテーブル（またはファイル）を用意する。

### **2.11. システムの健全性と自己調整 (System Health & Self-Tuning)**

* **コンセプト:** AIが自身の活動を定量的に観測し、パフォーマンスを評価し、振る舞いを自律的に調整する、自己改善のメカニズム。  
* **主要なメトリクス (観測対象):**  
  * issue\_count\_open, issue\_count\_total  
  * issue\_close\_avg\_hours: Issueが閉じるまでの平均時間  
  * flow\_count\_active, flow\_count\_total  
  * flow\_churn\_rate\_weekly: 1週間のFlowの新陳代謝率  
  * knowledge\_count\_total  
  * pond\_size, pond\_salvage\_rate  
  * agent\_loop\_count\_daily: 1日の思考ループ実行回数  
* **実装戦略:**  
  1. **統計情報の収集:** D-2ワークフローが定期的に上記のメトリクスを計算し、DB内の専用テーブルに記録する。  
  2. **目標値の設定:** 「Issueは平均48時間以内に閉じられるべき」といった目標値を、type: 'system\_rule'のKnowledgeとしてユーザーが（あるいはAI自身が）定義できるようにする。  
  3. **自律的な調整:** D-1ワークフローが、現在の統計値と目標値を比較する。大きな乖離がある場合、Pondのサルベージ頻度やFlowの優先度計算ロジックの重み付けなど、他のsystem\_ruleとして定義されたチューニングパラメータを更新し、自身の振る舞いを調整する。  
  4. **段階的な学習:** 初期状態では汎用的な目標値とパラメータを設定しておき、システムの使用を通じてユーザーの活動パターンを学習し、徐々に最適化していく。

## **3\. プロジェクト構成案**

npm workspacesを用いたモノレポ構成を採用し、関心事を明確に分離する。  
`/monorepo-root`  
  `├─ package.json`  
  `└─ /packages`  
     `├─ core/          # 思考ロジックの本体`  
     `├─ api-rest/      # coreの機能を公開するRESTサーバー`  
     `├─ web-ui/        # データ閲覧用のSvelteKit UI`  
     `├─ mcp-server/    # 外部AIが使うサーバープロセス`  
     `├─ reporters/     # 各Reporterの実装`  
     `├─ db/            # LanceDBを操作するTypeScript/Pythonブリッジ`  
     `│  ├─ src/`  
     `│  │  ├─ index.ts      # TypeScriptラッパー (高レベルAPI)`  
     `│  │  └─ python/`  
     `│  │     ├─ lancedb_worker.py # Python JSON-RPCワーカー`  
     `│  │     └─ requirements.txt`  
     `│  └─ package.json`  
     `└─ shared-types/  # パッケージ間で共有する型定義`

## **4\. Proof of Concept (PoC) 開発計画案**

1. **Step 1: プロジェクトセットアップとデータモデル定義**  
   * npm workspacesの構成を作成し、shared-typesにデータモデルを定義。  
2. **Step 2: DBブリッジの実装**  
   * dbパッケージに、stdinを監視してIssueを追加・検索できる最小限のPythonワーカーと、単一のState文書を読み書きする機能を実装。  
   * dbパッケージに、そのワーカーとJSON-RPCで通信するTypeScriptラッパーを実装。  
3. **Step 3: CoreロジックとREST APIの実装**  
   * coreにINDIVIDUAL\_INGEST\_INPUTイベントを実装し、dbパッケージのラッパーを呼び出すようにする。  
   * api-restに/request, /state, /statsエンドポイントを実装。  
4. **Step 4: エンドツーエンドでの疎通確認**  
   * mcp-serverからリクエストを送信し、api-rest → core → db → Pythonワーカー → LanceDBという流れでデータが保存されることを確認する。  
5. **Step 5: 簡易UIの実装**  
   * web-uiパッケージに、api-restからIssueの一覧と現在のState文書、そして基本的な統計情報を取得して表示するだけのシンプルなページを作成する。