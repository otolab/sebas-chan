# ワークフロー統合テストシナリオ仕様書

## 概要

このドキュメントは、sebas-chanの「安全なフォーゲッタ」としての機能を検証するテストシナリオを記述します。ユーザーの認知的負荷を軽減し、スケジュール管理や個人タスク管理を支援する観点から、各ワークフローの動作を検証します。

## システムの基本思想

sebas-chanは以下の役割を果たします：
- **外部脳**: ユーザーが安心して忘れられる情報管理
- **スケジュール管理**: 予定とタスクの追跡
- **リマインダー**: 最適なタイミングでの通知
- **知識の蓄積**: 経験から学習し、将来に活用

### 情報管理の2層構造
- **Knowledge（長期記憶）**: 恒久的な知識、ベストプラクティス、参照情報
- **State（短期記憶）**: 一時的なメモ、確認事項、進行中のコンテキスト
  - 例：「ユーザーに確認したいこと」「前回の会話の続き」「作業中のメモ」


## テストシナリオ一覧

### 1. IngestInput ワークフロー（外部情報の取り込み）

#### シナリオ1-1: 緊急対応が必要なタスクの認識

**入力データ:**
```
source: "slack"
content: "本番環境でログイン処理が失敗しています。DBへの接続がタイムアウトになり、500エラーが返されます。"
```

**期待される動作:**
1. AIが内容を分析し、緊急度を判定
2. 対応が必要なタスクとしてIssueが作成される
   - title: "本番環境でログイン処理が失敗"
   - labels: ["urgent", "production-issue", "source:slack"]
   - priority: 高（70以上）
3. HIGH_PRIORITY_DETECTEDイベントが発行される（緊急対応が必要な事態として）
4. ISSUE_CREATEDイベントが発行され、後続の分析がトリガーされる

**検証ポイント:**
- AIが緊急性を正しく判定
- ユーザーが忘れてはいけない重要タスクとして記録される
- 適切なスケジューリング優先度が設定される

#### シナリオ1-2: 既存タスクへの情報追加

**前提条件:**
- Issue「ログイン機能の改善」が既に存在

**入力データ:**
```
source: "email"
content: "ログイン画面で同じエラーが再発。特定のユーザーアカウントでのみ発生する模様。"
```

**期待される動作:**
1. AIが既存Issueとの関連性を認識
2. 既存Issueが更新される
   - 新しい情報がupdatesに追加
   - sourceInputIdsにPond IDが追加
3. ISSUE_UPDATEDイベントが発行される

**検証ポイント:**
- 類似内容の適切なマッチング
- 重複タスク作成の回避
- 更新履歴の正確な記録

#### シナリオ1-3: スケジュール変更の通知と管理

**入力データ:**
```
source: "teams"
content: "来週の定例会議は月曜日の午後3時に変更になりました。"
```

**期待される動作:**
1. AIがスケジュール変更として認識
2. 「定例会議」に関するIssueを検索
   - 既存Issueがあれば更新
   - なければ新規作成（title: "定例会議のスケジュール管理"）
3. スケジュール情報を抽出
   - 日時: "月曜日の午後3時"（具体的な日付が不明な場合は推定）
4. SCHEDULE_TRIGGERED用のスケジュール登録を提案
5. ISSUE_CREATED/UPDATEDイベントが発行される

**検証ポイント:**
- スケジュール情報の適切な抽出
- ユーザーの予定管理をサポート
- 曖昧な日時表現への対応（「来週の月曜日」の解釈）

#### シナリオ1-4: 日常的なメモの取り込み

**入力データ:**
```
source: "manual"
content: "コーヒーを買う。プリンターのインクも切れそう。"
```

**期待される動作:**
1. AIが買い物リスト/備忘録として認識
2. 「買い物リスト」または「備品管理」のIssueとして整理
3. 適切な優先度設定（低〜中）
4. Stateに「買い物予定の確認」を追加
   - 「いつ買い物に行く予定ですか？」等の質問を保存
5. 必要に応じてリマインダー設定（例：週末の買い物時）

**検証ポイント:**
- 日常的なタスクの適切な分類
- Stateを使った短期的な確認事項の管理
- 過度な優先度設定の回避

#### シナリオ1-5: コンテキスト不明な情報の処理

**入力データ:**
```
source: "slack"
content: "バージョン2.3.1でエラーが発生"
```

**期待される動作:**
1. AIがコンテキスト不足を認識
2. Stateに確認事項を記録
   - 「どのシステムのバージョン2.3.1ですか？」
   - 「どのようなエラーですか？」
3. 暫定的なIssue作成（タイトル：「不明なエラー報告」）
4. ユーザーへの確認を促すイベント発行

**検証ポイント:**
- コンテキスト不足の適切な認識
- Stateを使った質問事項の管理
- 情報不足でも可能な限りの処理を実行

### 2. ProcessUserRequest ワークフロー（ユーザーリクエスト処理）

#### シナリオ2-1: コンテキスト付きパフォーマンス問題のメモ

**前提Knowledge:**
```
- ユーザーはWebサービスの開発者
- 担当システム：ECサイトのバックエンドAPI
```

**入力データ:**
```
userId: "user-001"
content: "APIのレスポンスが異常に遅いです。通常1秒以内なのに、今は10秒以上かかっています。"
metadata: {
  context: "work",
  project: "ec-backend"
}
```

**期待される動作:**
1. Knowledgeからユーザーの役割を参照
2. requestType: "issue"と分類（仕事関連と認識）
3. 既存の「ECサイトパフォーマンス」関連Issueを検索
4. 緊急度を高めに判定（本番影響の可能性）
5. Stateに調査項目を記録
   - 「どのAPIエンドポイントですか？」
   - 「いつから発生していますか？」
6. ユーザーへの応答と次のアクション提案

**検証ポイント:**
- Knowledgeを活用したコンテキスト理解
- 職務に応じた適切な優先度判定
- Stateを使った追加情報の収集

#### シナリオ2-2: プロジェクト関連の技術的質問

**前提Knowledge:**
```
- プロジェクト「ECサイト」のAPI仕様書が存在
- 認証方式：JWT Bearer Token
```

**入力データ:**
```
userId: "user-002"
content: "REST APIの認証方法を教えてください。JWTトークンはどこで取得できますか？"
metadata: {
  context: "work",
  project: "ec-backend"
}
```

**期待される動作:**
1. requestType: "question"と分類
2. プロジェクト関連のKnowledgeを優先検索
3. 既存のAPI仕様書から回答を生成
4. Stateに確認事項を追加
   - 「開発環境用ですか、本番環境用ですか？」
5. KNOWLEDGE_EXTRACTABLEイベントが発行
6. 「API認証ガイド」の更新提案

**検証ポイント:**
- プロジェクトコンテキストの活用
- 既存Knowledgeの効果的な参照
- 追加情報の適切な収集

#### シナリオ2-3: フィードバックの記録と活用

**入力データ:**
```
userId: "user-003"
content: "新しいダッシュボード機能、とても使いやすいです！データの可視化が分かりやすくなりました。"
```

**期待される動作:**
1. requestType: "feedback"と分類
2. KNOWLEDGE_EXTRACTABLEイベントが発行
   - suggestedCategory: "best_practice"
3. 「UI改善」関連のIssueに記録
4. 感謝のメッセージ返信

**検証ポイント:**
- ポジティブフィードバックの適切な活用
- ベストプラクティスとしての知識化

#### シナリオ2-4: 個人タスクの追加

**入力データ:**
```
userId: "user-004"
content: "明日までにプレゼン資料を完成させる必要がある"
```

**期待される動作:**
1. requestType: "task"と分類
2. 締切を認識（「明日まで」）
3. タスクとしてIssue作成
   - title: "プレゼン資料の完成"
   - deadline: 明日の終業時刻
4. スケジューラーでリマインダー設定
   - 今日の夕方: 進捗確認
   - 明日の朝: 最終確認
5. ユーザーへの応答
   - 「タスクを登録しました。今日の夕方と明日の朝にリマインドします」

**検証ポイント:**
- 締切の正確な認識
- 適切なリマインダータイミング
- ユーザーの忘却を防ぐサポート

### 3. AnalyzeIssueImpact ワークフロー（タスクの影響分析）

#### シナリオ3-1: 締切が近いタスクの優先度上昇

**入力Issue:**
```
title: "月次レポート作成"
description: "今月の売上レポートを作成"
updates: ["作成開始", "データ収集中"]
deadline: 2日後
status: "open"
```

**期待される動作:**
1. 締切までの時間を考慮
2. suggestedPriority: 80以上に上昇
3. HIGH_PRIORITY_DETECTEDイベント発行
4. リマインダー頻度の増加を提案

**検証ポイント:**
- 時間経過による優先度の動的調整
- 締切に応じた適切なエスカレーション

#### シナリオ3-2: 完了可能タスクの自動クローズ判定

**入力Issue:**
```
title: "定期ミーティングの準備"
updates: [
  "議題作成完了",
  "資料準備完了",
  "参加者への連絡完了"
]
status: "open"
```

**期待される動作:**
1. shouldClose: trueと判定
2. closeReason: "すべての準備が完了"
3. ISSUE_STATUS_CHANGEDイベント発行
4. 完了タスクとして知識化を提案

**検証ポイント:**
- タスク完了条件の適切な判定
- ユーザーの確認なしでのクローズ可否判断

#### シナリオ3-3: 関連タスクの統合提案

**入力Issue:**
```
title: "会議室予約"
description: "来週の会議の部屋を予約"
```

**関連Issue:**
```
既存Issue: "来週の会議準備"
```

**期待される動作:**
1. shouldMergeWith: ["existing-issue-id"]
2. relationsに"relates_to"が追加
3. 統合によるタスク管理の簡素化を提案

**検証ポイント:**
- 関連タスクの適切な検出
- タスク管理の効率化提案

### 4. ExtractKnowledge ワークフロー（経験の知識化）

#### シナリオ4-1: 完了タスクからのベストプラクティス抽出

**入力データ:**
```
sourceType: "issue"
sourceId: "task-completed-001"
Issue内容: {
  title: "プレゼン資料作成",
  updates: ["構成検討", "デザイン作成", "レビュー完了", "発表成功"]
}
```

**期待される動作:**
1. 知識タイプ: "best_practice"と分類
2. プレゼン作成の手順として構造化
3. タグ: ["presentation", "workflow", "成功事例"]
4. 次回の類似タスクで参照可能に

**検証ポイント:**
- 成功パターンの抽出
- 再利用可能な形式での保存

#### シナリオ4-2: 失敗からの学習

**入力データ:**
```
sourceType: "issue"
Issue内容: {
  title: "締切遅延",
  description: "レポート提出が締切に間に合わなかった",
  updates: ["見積もり不足", "他タスクとの競合"]
}
```

**期待される動作:**
1. 知識タイプ: "lesson_learned"と分類
2. 改善点として記録
3. 次回の見積もり時に警告として活用

**検証ポイント:**
- 失敗パターンの認識
- 将来の予防策としての活用

### 5. ワークフローチェーン統合シナリオ

#### シナリオ5-1: タスク登録から完了まで（完全フロー）

**フロー:**
1. ユーザー: 「来週までに予算案を作成」
2. ProcessUserRequest → タスク作成
3. AnalyzeIssueImpact → リマインダー設定
4. SCHEDULE_TRIGGERED → 進捗確認
5. ユーザー: 「完了しました」
6. ExtractKnowledge → ベストプラクティス保存

**検証ポイント:**
- タスクのライフサイクル全体の管理
- 適切なタイミングでのユーザーサポート
- 完了後の知識化

#### シナリオ5-2: 複数タスクの並列管理

**入力:**
- タスク1: 「明日までにメール返信」
- タスク2: 「今週中に経費精算」
- タスク3: 「月末までに研修申込」

**期待される動作:**
1. 各タスクの優先度判定
2. 自然言語でのリマインダー設定
   - 「明日の朝9時にリマインド」
   - 「週末までに経費精算のリマインド」
   - 「月末3日前に研修申込のリマインド」
3. Stateに実行順序の提案を記録
   - 「本日：メール返信の準備」
   - 「今週後半：経費精算」
   - 「来週：研修申込」
4. タスク間の依存関係分析

**検証ポイント:**
- 自然言語スケジュール解釈の精度
- 複数タスクの並列処理
- Stateを使った実行計画の管理

## 異常系シナリオ

### エラー1: 曖昧な日時表現

**状況:** 「そのうち対応」「できるだけ早く」等の曖昧な表現

**期待される動作:**
- ユーザーに具体的な日時の確認
- デフォルト値の設定（例：1週間後）
- 定期的な状況確認

### エラー2: 矛盾する情報

**状況:** 「緊急ではないが今すぐ対応必要」等の矛盾

**期待される動作:**
- 矛盾の検出と指摘
- ユーザーへの確認
- 安全側の判断（緊急として扱う）

### エラー3: 意味不明な入力

**状況:** 「あsdfｊｋｌ；おｐｑｗ」等の無意味な文字列

**期待される動作:**
- 無意味な入力として認識
- Issueは作成しない
- Pondには記録（後で意味が判明する可能性）
- Stateに「入力内容の確認」を記録
- ユーザーへの確認メッセージ

## テスト実装の優先順位

### Phase 1: 基本機能の検証
1. コンテキスト付きタスク管理（シナリオ2-1, 2-4）
2. Stateを使った短期記憶の活用（シナリオ1-4, 1-5）
3. Knowledge参照の基本動作（シナリオ2-2）

### Phase 2: 高度な機能
1. 自然言語スケジューリング（シナリオ5-2）
2. タスクライフサイクル管理（シナリオ5-1）
3. 異常系の処理（エラーシナリオ）

### Phase 3: 最適化と学習
1. 知識の抽出と活用（シナリオ4-1, 4-2）
2. 複雑なワークフローチェーン
3. パフォーマンス最適化

## 今後の検討事項

- Flowベースの曖昧タスク管理
- 自然言語スケジューラーとの統合テスト
- ユーザープロファイルに基づく動的優先度調整
- 長期的な学習効果の測定