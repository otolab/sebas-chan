# ドキュメントとコードの同期管理

## 基本原則

### ドキュメント・テスト・コード同期の原則

**ドキュメント・テスト・コードを往復して開発する作業において、「正とするのは何か」という判断があって、そこから作業が決まる**

### 作業フロー

1. **不整合を発見したら、まず「何を正とするか」を判断**
   - これは固定的なルールではなく、状況に応じた判断
   - 現在の開発フェーズ、変更の目的、品質の状態を考慮

2. **正の判断基準例**
   - 探索的開発：動作するコードが正（実装を通じて仕様を発見）
   - テスト駆動開発：テストが正（望ましい振る舞いを定義）
   - 仕様変更：新しい要求が正（ドキュメント・コード・テストすべて修正対象）
   - バグ修正：期待される動作が正（ドキュメントまたはテストに記載）
   - リファクタリング：テストが正（振る舞いを変えずに実装を改善）

3. **正を決めたら、それに合わせて他を修正**
   - 正とした対象は変更しない
   - 正に合わせて他の要素を修正
   - 修正後、三者の整合性を確認

4. **往復開発の実践**
   - ドキュメント ⇄ コード ⇄ テストの間を往復
   - 各段階で「今何を正としているか」を明確に意識
   - 不整合を発見したら立ち止まって判断

### 注意点
- **「正」は固定的ではない**：開発の進行とともに変化する
- **判断の根拠を明確に**：なぜそれを正としたかを説明できるように
- **整合性の確認を怠らない**：修正後は必ず三者の一致を確認

## 同期の概念

### 双方向の反映関係

ドキュメントとコードは互いに全射の関係にあるべきです：

- **コードの更新はドキュメントに反映されるべき**
  - API変更、機能追加、仕様変更の際は対応するドキュメントを更新
  - 実装の詳細がドキュメントの説明と矛盾しないよう保つ

- **ドキュメントの更新もコードに反映されるべき**
  - 仕様書やAPIドキュメントの変更に合わせて実装を調整
  - ドキュメントが示す設計意図を実装で実現

- **粒度と表現の違い**
  - ドキュメントは、コードの一部分ではなく全体を反映したもの
  - 同じ概念を異なる粒度と表現で記述したもの
  - 一つのドキュメントが複数のファイルの反映を含む場合がある

### テストの役割と分類

テストはもう一つのドキュメントとして重要な役割を果たします：

**動作テストと仕様テストの分類：**

- **動作テスト**：コードを反映して作られるテスト
  - 現在の実装が正しく動作することを確認
  - リファクタリング時の安全性を保証
  - 実装の変更による影響を検出

- **仕様テスト**：ドキュメントを反映して作られるテスト
  - ドキュメントに記載された仕様を保証
  - 実装がドキュメントの意図通りに動作することを確認
  - 仕様を保証するためのものとして非常に重要

**テストの活用方針：**
- 継続的なテスト改善：テストの改善は常に行われるべき
- 積極的なテスト生成：必要があればテストコードを積極的に生成する
- 仕様保証のテスト：ドキュメントされた内容を保証するためのテストを重視

## 同期作業の実践

### 前提条件

実際の開発では、コードとドキュメントの変更は常に同期して行われるわけではありません。多くの場合、以下のような状況で不一致が検出されます：

- 定期的なドキュメントレビューの際
- 機能実装後のドキュメント確認時
- 新しいメンバーのオンボーディング時
- バグ報告やユーザーからの問い合わせ時
- リリース前の最終確認時

このような**「不一致・矛盾の検出」**が同期作業の起点となります。

### 包括的確認の原則

一つのドキュメントが複数のファイルの反映である場合：

1. **すべての関連ファイルを読み込む**
   - ドキュメントで言及されているすべての実装ファイル
   - 間接的に影響を受ける関連ファイル
   - 設定ファイルや型定義ファイル
   - テストファイル：動作確認と意図理解のため

2. **全体的な一致を確認する**
   - 個別のファイルだけでなく、ファイル間の関係性も含めて確認
   - システム全体としての整合性を検証
   - 依存関係や呼び出し関係の正確性

3. **必要に応じて修正する**
   - 不一致が発見された場合の修正方針を決定
   - コード側を修正するかドキュメント側を修正するかの判断
   - 修正による他の部分への影響を評価

### 不一致・矛盾発見時の対応

1. **不一致の性質と範囲の特定**
   - どのような種類の不一致か（概念的、仕様的、例示的、命名的）
   - 影響を受けるドキュメントとコードの範囲を把握
   - 不一致が発生した原因の推定

2. **関連情報の収集**
   - 影響するすべての実装ファイルを確認
   - 関連するテストコードの動作状況を把握
   - 設定ファイルや型定義ファイルとの整合性を確認

3. **修正方針の決定（何を正とするかの判断）**
   - 現在の開発フェーズと変更の目的を考慮
   - 探索的開発中ならコードを正とすることが多い
   - テスト駆動開発中ならテストを正とする
   - 仕様変更なら新しい要求を正とする
   - リファクタリング中ならテストを正とする

4. **修正作業の実行**
   - 決定した「正」に基づいて他の要素を修正
   - 全体の流れや構造への影響を考慮
   - 読み手にとっての理解しやすさを維持

5. **補完作業**
   - 既存の動作テストの確認と改善
   - ドキュメント仕様を保証する仕様テストの生成

### 例外的対応：コードファイルへのコメント追加

ドキュメントとコードの一致が取りづらい場合（解釈のミスをユーザーに指摘された場合など）には、コードファイルにコメントを追加してコードを補強することがあります。

**注意点：**
- これはコードファイルの修正ですが、実質的なコードの修正ではない
- コードはドキュメントではないので、過剰に説明する必要はない
- 必要最小限の補足説明に留める

### 例外的ケース：設計変更時の対応

設計変更等でドキュメントからコードへの反映が必要な場合：

1. **ユーザーコミュニケーションの実施**
   - コードの修正は意図されていない可能性が高いため、必ずユーザーに確認
   - 質問やIssueの起票を通じて修正の妥当性を確認
   - 設計変更の背景と影響範囲をユーザーと共有

2. **実装への影響の評価**
   - ドキュメントの変更がコードに与える影響を分析
   - 実装の修正が必要かどうかの判断
   - 破壊的変更の可能性を検討

3. **実装状況の確認**
   - 現在の実装がドキュメントの記述と一致しているかを確認
   - 不一致がある場合の原因分析
   - 既存のテストによる実装の動作確認

4. **テスト先行での変更実行**
   - **可能であれば、テストを先に作成**してから実装を修正
   - 設計変更に基づく仕様テストの作成
   - 設計変更に基づく実装修正
   - 関連する他の部分への波及的な修正

## 品質保証

### 継続的な確認

- 定期的な全体チェック
  - プロジェクト全体のドキュメントとコードの整合性を定期的に確認
  - 長期間放置された不一致の発見と修正

- 変更時の即座な確認
  - コードやドキュメントの変更時に即座に同期状況を確認
  - 問題の早期発見と迅速な修正

### 確認の観点

**基本的な一致確認：**
- 概念的一致：ドキュメントの説明とコードの実装が同じ概念を表現している
- 仕様的一致：APIや設定の仕様がドキュメントと実装で一致している  
- 例示的一致：ドキュメント内の使用例が実際の実装で動作する
- 命名的一致：関数名、変数名、設定項目名がドキュメントと実装で一致している

**品質と完全性の確認：**
- 機能的正確性：説明されている機能が実際に動作する
- 概念的一貫性：同じ概念が一貫した方法で説明されている
- 完全性：重要な機能や仕様が適切にドキュメント化されている
- コメント補完性：コードの意図がドキュメントとコメントで十分に伝わる

**テスト関連の確認：**
- テスト整合性：テストケースがドキュメントの記述と実装の両方と一致している
- 仕様保証性：ドキュメントに記載された仕様がテストによって確実に保証されている
- 動作保証性：実装の動作がテストによって継続的に検証されている

### 修正の優先順位

1. 機能に影響する不一致：最優先で修正
2. 仕様保証テストの不足：高優先度で修正・追加
3. 理解に影響する不一致：高優先度で修正
4. 動作テストの改善：継続的に実施
5. 表現の不統一：適切なタイミングで修正
6. 軽微な表記揺れ：他の作業と合わせて修正

この同期管理により、ドキュメントとコードが常に一致した状態を保ち、プロジェクトの品質と保守性を向上させることができます。